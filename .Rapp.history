mu300=mu[mu$genoCut==300,]
mu300
library(ggplot2)
mu300$ind=seq(1:nrow(mu300))
mu300
ggplot(mu,aes(ind,mutRate))+geom_bar(stat=identity)
ggplot(mu,aes(ind,mutRate))+geom_bar(stat="identity")
ggplot(mu300,aes(ind,mutRate))+geom_bar(stat="identity")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_y_log10(breaks=c(1e-7,1.5e-7,3e-7,6e-7))
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,title="depth")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()
mu300
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=0)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error))
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=-1)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=1)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.5,type=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.5,ltype=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.5,line.type=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.5)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.5,linetype=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=1,linetype=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.8,linetype=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")+geom_hline(yintercept=1.5e-7,size=0.6,linetype=3)
ggplot(mu300,aes(ind,mut.rate))+geom_bar(stat="identity")+scale_x_continuous(breaks=mu300$ind,labels=mu300$depth,)+xlab("depth")+ylab("mutation rate")+theme_bw()+geom_text(aes(label=mut.count.minus.error),vjust=2,col="white")
install.packages("MCMC.QPCR")
install.packages("MCMC.qpcr")
?MCMC.qpcr
library(MCMC.qpcr)
?MCMC.qpcr
data(beckham.data)#
data(beckham.eff)#
#
# analysing the first 5 genes #
# (to try it with all 10 genes, change the line below to gcol=4:13)#
gcol=4:8 #
ccol=1:3 # columns containing experimental conditions#
#
# recalculating into molecule counts, reformatting#
qs=cq2counts(data=beckham.data,genecols=gcol,#
condcols=ccol,effic=beckham.eff,Cq1=37)#
#
# creating a single factor, 'treatment.time', out of 'tr' and 'time'#
qs$treatment.time=as.factor(paste(qs$tr,qs$time,sep="."))#
#
# fitting a naive model#
naive=mcmc.qpcr(#
	fixed="treatment.time",#
	data=qs,#
	nitt=3000,burnin=2000 # remove this line in actual analysis!#
)#
#
#summary plot of inferred abundances#
#s1=HPDsummary(model=naive,data=qs)#
#
#summary plot of fold-changes relative to the global control#
s0=HPDsummary(model=naive,data=qs,relative=TRUE)#
#
# pairwise differences and their significances for each gene:#
s0$geneWise
qs
?MCMC.qpcr
s1=HPDsummary(model=naive,data=qs)
cca=read.csv("~/Documents/CCA_anna/cca_anna.csv")
cca
str(cca)
library(MCMCglmm)
str(cca)
cca$Algae_score=factor(cca$Algae_score)
cca$Algae_score=factor(cca$Algae_score,levels=c(4,3,2,1))
lat=MCMCglmm(Coral_diversity~Algae_score,cca[!is.na(cca$Coral_Diversity),],family="poisson")
lat=MCMCglmm(Coral_diversity~Algae_score,data=cca[!is.na(cca$Coral_Diversity),],family="poisson")
!is.na(cca$Coral_Diversity)
lat=MCMCglmm(Coral_diversity~Algae_score,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(lat)
str(cca)
coral=MCMCglmm(Coral_diversity~Algae_score,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(coral)
dweller=MCMCglmm(Dweller_diversity~Algae_score,data=cca[!is.na(cca$Dweller_diversity),],family="poisson")#
summary(dweller)
cca$Algae_score=as.numeric(cca$Algae_score)
coral=MCMCglmm(Coral_diversity~Algae_score,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(coral)
plot(Coral_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y")
cca$Algae_score=factor(cca$Algae_score,levels=c(4,3,2,1))
plot(Coral_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y")
ll=lm(log(Coral_diversity)~Algae_score,cca[!is.na(cca$Coral_diversity),])
par(mfrow=c(2,2))#
plot(ll)
ll=lm(log(Dweller_diversity)~Algae_score,cca[!is.na(cca$Coral_diversity),])#
par(mfrow=c(2,2))#
plot(ll)
plot(Dweller_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y")
summary(ll)
ll=lm(log(Coral_diversity)~Algae_score,cca[!is.na(cca$Coral_diversity),])#
par(mfrow=c(2,2))#
plot(ll)#
summary(ll)
ll=lm(log(Dweller_diversity)~Algae_score,cca[!is.na(cca$Coral_diversity),])#
par(mfrow=c(2,2))#
plot(ll)#
summary(ll)
plot(Dweller_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y")
str(cca)
ll=lm(Thick~Algae_score,cca[!is.na(cca$Coral_diversity),])
ll=lm(Thick~Algae_score,cca[!is.na(cca$Thick),])
par(mfrow=c(2,2))#
plot(ll)
ll=lm(log(Thick)~Algae_score,cca[!is.na(cca$Thick),])
par(mfrow=c(2,2))#
plot(ll)
summary(ll)
plot(Thicky~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y")
plot(Thick~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y")
cca=read.csv("~/Documents/CCA_anna/cca_anna.csv")#
str(cca)#
cca$Algae_score=factor(cca$Algae_score)
par(mfrow=c(2,2))#
plot(Coral_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y",main="coral")#
plot(Dweller_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y"main="dweller")#
plot(Thick~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y",main="thick")
par(mfrow=c(2,2))#
plot(Coral_diversity~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y",main="coral")#
plot(Dweller_diversity~Algae_score,cca[!is.na(cca$Dweller_diversity),],log="y"main="dweller")#
plot(Thick~Algae_score,cca[!is.na(cca$Coral_diversity),],log="y",main="thick")
plot(Dweller_diversity~Algae_score,cca[!is.na(cca$Dweller_diversity),],log="y",main="dweller")
ll=lm(log(Coral_diversity)~Algae_score,cca[!is.na(cca$Coral_diversity),])#
par(mfrow=c(2,2))#
plot(ll)#
summary(ll)
ll=lm(log(Dweller_diversity)~Algae_score,cca[!is.na(cca$Coral_diversity),])#
par(mfrow=c(2,2))#
plot(ll)#
summary(ll)
ll=lm(log(Thick)~Algae_score,cca[!is.na(cca$Thick),])#
par(mfrow=c(2,2))#
plot(ll)#
summary(ll)
plot(Algae_score~Paleolat,data=cca[!is.na(cca$Paleolat),]
plot(Algae_score~Paleolat,data=cca[!is.na(cca$Paleolat),])
str(cca)
plot(log(Coral_diversity)~Paleolat,data=cca[!is.na(cca$Paleolat),])
cca$as_num=as.numeric(cca$Algae_score)
plot(as_num~Paleolat,data=cca[!is.na(cca$Paleolat),])
cca=read.csv("~/Documents/CCA_anna/cca_anna.csv")
str(cca)
cca$as_num=as.numeric(cca$Algae_score)
cca=read.csv("~/Documents/CCA_anna/cca_anna.csv")
str(cca)
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_Builder,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
coral=MCMCglmm(Coral_diversity~Algae_score,random=Primary_Builder,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_Builder,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
str(cca)
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_builder,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(coral)
cca$Algae_score=factor(cca$Algae_score)
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_builder,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(coral)
str(cca)
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_builder+Reef_Type,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_builder+Reefy_pe,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_builder+Reefy_type,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Primary_builder+Reef_type,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(coral)
coral=MCMCglmm(Coral_diversity~Algae_score,random=~Reef_type,data=cca[!is.na(cca$Coral_diversity),],family="poisson")
summary(coral)
plot(log(Coral_diversity)~Reef_type,data=cca[!is.na(cca$Coral_diversity),])
plot(log(Coral_diversity)~Primary_builder,data=cca[!is.na(cca$Primary_builder),])
dweller=MCMCglmm(Dweller_diversity~Algae_score,random=~Reef_type,data=cca[!is.na(cca$Dweller_diversity),],family="poisson")
summary(dweller)
plot(Dweller_diversity~Algae_score,cca[!is.na(cca$Dweller_diversity),],log="y",main="dweller")
coral2=MCMCglmm(Coral_diversity~as_num,random=~Primary_builder+Reef_type,data=cca[!is.na(cca$Coral_diversity),],family="poisson")#
summary(coral2)
cca$as_num=as.numeric(cca$Algae_score)
coral2=MCMCglmm(Coral_diversity~as_num,random=~Primary_builder+Reef_type,data=cca[!is.na(cca$Coral_diversity),],family="poisson")#
summary(coral2)
dweller2=MCMCglmm(Dweller_diversity~as_num,random=~Reef_type,data=cca[!is.na(cca$Dweller_diversity),],family="poisson")#
summary(dweller2)
plot(Dweller_diversity~as_num,cca[!is.na(cca$Dweller_diversity),],log="y",main="dweller")
coral=read.csv("~/Documents/Kenkel_RTexpression_2016/kenkelRT_DAPCscores/Host_IndividCoord_DFA_7008genes.csv")
coral
grep("[0=9]*",coral$X)
grep("[0-9]*",coral$X)
grep("10",coral$X)
gt=gsub("i|o|A|C","",coral$X)
gt
coral$gt=gsub("i|o|A|C","",coral$X)
coral$ori=sub("oo|oi","o",coral$group)
coral$ori=sub("io|ii","i",coral$ori)
coral
coral$away[coral$group %in% c("oi","io")]=1
coral
coral$away=0#
coral$away[coral$group %in% c("oi","io")]=1
coral
library(MCMCglmm)
cd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=coral)
summary(cd)
plot(cd)
prior = list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V=1, nu=0.002,alpha.mu=0, alpha.V=1000)))
cd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=coral,prior=prior)
plot(cd)
summary(cd)
awayDelta=abs(cd$Sol[,"orii:away"])-abs(cd$Sol[,"orio:away"])
HPDinterval(awayDelta)
table(awayDelta<0)
awayRatio=abs(cd$Sol[,"orii:away"])/abs(cd$Sol[,"orio:away"])
HPDinterval(awayRatio)
table(awayRatio<1) #1
mean(awayRatio)
HPDinterval(awayDelta)
sym=read.csv("~/Documents/Kenkel_RTexpression_2016/kenkelRT_DAPCscores/Sym_IndividCoord_DFA_1174genes.csv")#
#
sym$gt=gsub("i|o|A|C","",sym$X)#
sym$ori=sub("oo|oi","o",sym$group)#
sym$ori=sub("io|ii","i",sym$ori)#
sym$away=0#
sym$away[sym$group %in% c("oi","io")]=1
symd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=sym,prior=prior)#
summary(symd)
SymAwayDelta=abs(symd$Sol[,"orii:away"])-abs(symd$Sol[,"orio:away"])
HPDinterval(SymAwayDelta)
table(SymAwayDelta <0) #1
54/1000
symd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=sym,prior=prior,nitt=55000, thin=25, burnin=5000)
summary(symd)
SymAwayDelta=abs(symd$Sol[,"orii:away"])-abs(symd$Sol[,"orio:away"])#
HPDinterval(SymAwayDelta)
table(SymAwayDelta <0) # 54
# so the MCMC-based p-value for higher change in inshores is 145/1855 = 0.054
145/1855
prior = list(R = list(V = 1, nu = 0.02), G = list(G1 = list(V=1, nu=0.02,alpha.mu=0, alpha.V=1000)))
symd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=sym,prior=prior,nitt=75000, thin=25, burnin=5000)
summary(symd)
SymAwayDelta=abs(symd$Sol[,"orii:away"])-abs(symd$Sol[,"orio:away"])#
HPDinterval(SymAwayDelta)#
          # lower    upper#
# var1 -0.1662582 2.010301#
table(SymAwayDelta <0) # 54
211/2800
symd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=sym,nitt=75000, thin=25, burnin=5000)
summary(symd)
SymAwayDelta=abs(symd$Sol[,"orii:away"])-abs(symd$Sol[,"orio:away"])#
HPDinterval(SymAwayDelta)
table(SymAwayDelta <0) # 54
218/2800
symd=MCMCglmm(LD1~ori+ori:away,random=~gt,prior=prior,data=sym,nitt=75000, thin=25, burnin=5000)
SymAwayDelta=abs(symd$Sol[,"orii:away"])-abs(symd$Sol[,"orio:away"])#
HPDinterval(SymAwayDelta)
table(SymAwayDelta <0) # 54
184/2800
table(awayRatio<1)[2] #1
table(awayRatio<1)[2]/length(awayRatio) #1
prior = list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V=1, nu=0.002,alpha.mu=0, alpha.V=1000)))#
cd=MCMCglmm(LD1~ori+ori:away,random=~gt,data=coral,prior=prior,nitt=75000, thin=25, burnin=5000)#
summary(cd)
awayDelta=abs(cd$Sol[,"orii:away"])-abs(cd$Sol[,"orio:away"])#
HPDinterval(awayDelta)#
       # lower    upper#
# var1 1.207062 3.717263#
#
#MCMC p-value#
table(awayDelta<0)[2]/length(awayDelta) #1
prior = list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V=1, nu=0.002,alpha.mu=0, alpha.V=1000)))#
symd=MCMCglmm(LD1~ori+ori:away,random=~gt,prior=prior,data=sym,nitt=75000, thin=25, burnin=5000)#
summary(symd)#
            # post.mean l-95% CI u-95% CI eff.samp  pMCMC    #
# (Intercept)     2.575    2.012    3.168     1000 <0.001 ***#
# orio           -4.699   -5.465   -3.866     1000 <0.001 ***#
# orii:away      -2.756   -3.570   -1.963     1000 <0.001 ***#
# orio:away       1.864    1.114    2.584     1000 <0.001 ***#
#
# difference in magnitudes of orii:away and orio:away:#
SymAwayDelta=abs(symd$Sol[,"orii:away"])-abs(symd$Sol[,"orio:away"])#
HPDinterval(SymAwayDelta)#
          # lower    upper#
# var1 -0.2836332 1.953451#
#
table(SymAwayDelta<0)[2]/length(SymAwayDelta) # 3.6e-4
coral=read.csv("~/Documents/Kenkel_RTexpression_2016/kenkelRT_DAPCscores/Host_IndividCoord_DFA_7008genes.csv")#
#
coral$gt=gsub("i|o|A|C","",coral$X)#
coral$ori=sub("oo|oi","o",coral$group)#
coral$ori=sub("io|ii","i",coral$ori)#
coral$away=0#
coral$away[coral$group %in% c("oi","io")]=1
coral
length(awayDelta)
bays=read.table("~/Documents/GRANTS/IOS2016/bay_coauthors.txt",sep="\t",header=T)
matzs=read.table("~/Documents/GRANTS/IOS2016/matz_coauthors.txt",sep="\t",header=T)
head(bays)
unique(bays$Name)
unique(c(bays$Name,$matzs$Name))
unique(c(bays$Name,matzs$Name))
c(bays$Name,matzs$Name)
unique(c(as.character(bays$Name),as.character(matzs$Name)))
unique(c(as.character(matzss$Name),as.character(bays$Name)))
unique(c(as.character(matzs$Name),as.character(bays$Name)))
names=unique(c(as.character(matzs$Name),as.character(bays$Name)))
strsplit(names,",| ")
strsplit(names,"\,|\s+",perl=T)
strsplit(names,"\\,|\\s+",perl=T)
strsplit(names,"\\,|\\s",perl=T)
strsplit(names,"\\,\s+|\\s",perl=T)
strsplit(names,"\\,\\s+|\\s",perl=T)
strsplit(names,"\\,\\s+|\\s",perl=T)[[]][1]
strsplit(names,"\\,\\s+|\\s",perl=T)[[1]]
strsplit(names,"\\,\\s+|\\s",perl=T)[[1:length(names)]]
1:length(names)
nlist=strsplit(names,"\\,\\s+|\\s",perl=T)
ldply(strsplit(names,"\\,\\s+|\\s",perl=T))
library(plyr)
ldply(strsplit(names,"\\,\\s+|\\s",perl=T))
strsplit(names,"\\,\\s+|\\s",perl=T)
names
# Edit these to match your data file names: #
input="blue.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="amil_defog_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="CC" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
#	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
input="floralwhite.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="amil_defog_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="CC" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
if (adjust.multcomp=="shuffle" | Module==TRUE){
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.5 if you are doing Fisher's exact test for standard GO enrichment or analyzing WGCNA module based on comb.#
	absValue=0.5,#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with
goDivision="MF" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.5 if you are doing Fisher's exact test for standard GO enrichment or analyzing WGCNA module based on comb.#
	absValue=0.5,#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE; shuffle=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, shuffle=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, shuffle=TRUE # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle" # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.5 if you are doing Fisher's exact test for standard GO enrichment or analyzing WGCNA module based on comb.#
	absValue=0.5,#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle" # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle";shuffle.reps=10 # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle",shuffle.reps=10 # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle",shuffle.reps=10 # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.5 if you are doing Fisher's exact test for standard GO enrichment or analyzing WGCNA module based on comb.#
	absValue=0.5,#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)
input="blue.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="amil_defog_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="MF" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle",shuffle.reps=10 # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.5 (count number of "good genes" that fall into the module)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
input="blue.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="amil_defog_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="MF" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead#
	Module=TRUE, adjust.multcomp="shuffle" # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.5 (count number of "good genes" that fall into the module)#
)
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. If Module==TRUE the method switches to one-tailed "g" option (assuming signed modules) #
	Module=TRUE, adjust.multcomp="shuffle" # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.5 (count number of "good genes" that fall into the module)#
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.5 if you are doing Fisher's exact test for standard GO enrichment or analyzing WGCNA module.#
	absValue=0.5,#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.01,level2=0.005,level3=0.001.
source("gomwu.functions.R")#
# Calculating stats. It takes ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. #
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. If Module==TRUE the method switches to one-tailed "g" option (assuming signed modules) #
	Module=TRUE, adjust.multcomp="shuffle" # un-remark this if you are analyzing a WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.5 (count number of "good genes" that fall into the module)#
)
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.5 if you are doing Fisher's exact test for standard GO enrichment or analyzing WGCNA module.#
	absValue=0.5,#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)
